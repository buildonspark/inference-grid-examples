// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.6.1
//   protoc               v5.29.3
// source: core.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";

export const protobufPackage = "core";

export enum Role {
  CLIENT = 0,
  PROVIDER = 1,
  UNRECOGNIZED = -1,
}

export function roleFromJSON(object: any): Role {
  switch (object) {
    case 0:
    case "CLIENT":
      return Role.CLIENT;
    case 1:
    case "PROVIDER":
      return Role.PROVIDER;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Role.UNRECOGNIZED;
  }
}

export function roleToJSON(object: Role): string {
  switch (object) {
    case Role.CLIENT:
      return "CLIENT";
    case Role.PROVIDER:
      return "PROVIDER";
    case Role.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum Status {
  ACTIVE = 0,
  PENDING = 1,
  INACTIVE = 2,
  UNRECOGNIZED = -1,
}

export function statusFromJSON(object: any): Status {
  switch (object) {
    case 0:
    case "ACTIVE":
      return Status.ACTIVE;
    case 1:
    case "PENDING":
      return Status.PENDING;
    case 2:
    case "INACTIVE":
      return Status.INACTIVE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Status.UNRECOGNIZED;
  }
}

export function statusToJSON(object: Status): string {
  switch (object) {
    case Status.ACTIVE:
      return "ACTIVE";
    case Status.PENDING:
      return "PENDING";
    case Status.INACTIVE:
      return "INACTIVE";
    case Status.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum ModelTier {
  TIER_0 = 0,
  TIER_1 = 1,
  TIER_2 = 2,
  TIER_3 = 3,
  TIER_4 = 4,
  UNRECOGNIZED = -1,
}

export function modelTierFromJSON(object: any): ModelTier {
  switch (object) {
    case 0:
    case "TIER_0":
      return ModelTier.TIER_0;
    case 1:
    case "TIER_1":
      return ModelTier.TIER_1;
    case 2:
    case "TIER_2":
      return ModelTier.TIER_2;
    case 3:
    case "TIER_3":
      return ModelTier.TIER_3;
    case 4:
    case "TIER_4":
      return ModelTier.TIER_4;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ModelTier.UNRECOGNIZED;
  }
}

export function modelTierToJSON(object: ModelTier): string {
  switch (object) {
    case ModelTier.TIER_0:
      return "TIER_0";
    case ModelTier.TIER_1:
      return "TIER_1";
    case ModelTier.TIER_2:
      return "TIER_2";
    case ModelTier.TIER_3:
      return "TIER_3";
    case ModelTier.TIER_4:
      return "TIER_4";
    case ModelTier.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum FeatureFlag {
  IMAGE = 0,
  TOOL_CALLS = 1,
  UNCENSORED = 2,
  OPEN_SOURCE = 3,
  UNRECOGNIZED = -1,
}

export function featureFlagFromJSON(object: any): FeatureFlag {
  switch (object) {
    case 0:
    case "IMAGE":
      return FeatureFlag.IMAGE;
    case 1:
    case "TOOL_CALLS":
      return FeatureFlag.TOOL_CALLS;
    case 2:
    case "UNCENSORED":
      return FeatureFlag.UNCENSORED;
    case 3:
    case "OPEN_SOURCE":
      return FeatureFlag.OPEN_SOURCE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return FeatureFlag.UNRECOGNIZED;
  }
}

export function featureFlagToJSON(object: FeatureFlag): string {
  switch (object) {
    case FeatureFlag.IMAGE:
      return "IMAGE";
    case FeatureFlag.TOOL_CALLS:
      return "TOOL_CALLS";
    case FeatureFlag.UNCENSORED:
      return "UNCENSORED";
    case FeatureFlag.OPEN_SOURCE:
      return "OPEN_SOURCE";
    case FeatureFlag.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface Identity {
  publicKey: Uint8Array;
  signature: Uint8Array;
  nonce: Uint8Array;
}

export interface Metadata {
  name: string;
  url: string;
  logoUrl: string;
  description: string;
}

export interface RegisterClientRequest {
  identity: Identity | undefined;
  metadata: Metadata | undefined;
}

export interface RegisterClientResponse {
  ok: boolean;
  invoice: string;
  message: string;
}

export interface RegisterProviderRequest {
  identity: Identity | undefined;
  metadata: Metadata | undefined;
}

export interface RegisterProviderResponse {
  ok: boolean;
  message: string;
}

export interface StatusRequest {
  publicKey: string;
}

export interface StatusResponse {
  publicKey: string;
  role: Role;
  status: Status;
  metadata: Metadata | undefined;
}

export interface ConnectionRequest {
  identity: Identity | undefined;
}

export interface ConnectionResponse {
  ok: boolean;
  message: string;
}

export interface Pricing {
  satsPerTokenIn: number;
  satsPerTokenOut: number;
  satsPerPixel: number;
}

export interface RegisterModelRequest {
  alias: string;
  tier: ModelTier;
  pricing: Pricing | undefined;
  flags: FeatureFlag[];
}

export interface RegisterModelResponse {
  ok: boolean;
  message: string;
}

export interface ChatCompletionMessageParts {
  parts: ChatCompletionMessagePart[];
}

export interface ChatCompletionMessagePart {
  type: string;
  text: string;
  imageUrl: ImageURL | undefined;
}

export interface ImageURL {
  url: string;
  detail: string;
}

export interface ChatCompletionMessage {
  role: string;
  content?: { $case: "text"; text: string } | { $case: "multi"; multi: ChatCompletionMessageParts } | undefined;
  name: string;
  toolCallId: string;
}

export interface ChatCompletionRequest {
  requestId: number;
  seed: number;
  maxTokens: number;
  temperature: number;
  tierSelector: string;
  flags: FeatureFlag[];
  responseFormat: ResponseFormat | undefined;
  tools: Tool[];
  messages: ChatCompletionMessage[];
}

export interface ResponseFormat {
  type: string;
}

export interface Tool {
  type: string;
  function: FunctionDescription | undefined;
}

export interface FunctionDescription {
  name: string;
  description: string;
  parameters: string;
}

export interface ToolCall {
  id: string;
  type: string;
  function: ToolCallFunction | undefined;
}

export interface ToolCallFunction {
  name: string;
  arguments: string;
}

export interface ChatCompletionPartial {
  requestId: number;
  index: number;
  message: string;
  toolCalls: ToolCall[];
  isComplete: boolean;
}

export interface ChatCompletionComplete {
  requestId: number;
  invoice: string;
  promptTokens: number;
  completionTokens: number;
}

export interface RevealPreimage {
  requestId: number;
  preimage: string;
}

export interface RelayError {
  requestId: number;
  message: string;
}

export interface MessageEnvelope {
  payload?:
    | { $case: "registerClientRequest"; registerClientRequest: RegisterClientRequest }
    | { $case: "registerClientResponse"; registerClientResponse: RegisterClientResponse }
    | { $case: "registerProviderRequest"; registerProviderRequest: RegisterProviderRequest }
    | { $case: "registerProviderResponse"; registerProviderResponse: RegisterProviderResponse }
    | { $case: "statusRequest"; statusRequest: StatusRequest }
    | { $case: "statusResponse"; statusResponse: StatusResponse }
    | { $case: "connectionRequest"; connectionRequest: ConnectionRequest }
    | { $case: "connectionResponse"; connectionResponse: ConnectionResponse }
    | { $case: "registerModelRequest"; registerModelRequest: RegisterModelRequest }
    | { $case: "registerModelResponse"; registerModelResponse: RegisterModelResponse }
    | { $case: "chatCompletionRequest"; chatCompletionRequest: ChatCompletionRequest }
    | { $case: "chatCompletionPartial"; chatCompletionPartial: ChatCompletionPartial }
    | { $case: "chatCompletionComplete"; chatCompletionComplete: ChatCompletionComplete }
    | { $case: "revealPreimage"; revealPreimage: RevealPreimage }
    | { $case: "relayError"; relayError: RelayError }
    | undefined;
}

function createBaseIdentity(): Identity {
  return { publicKey: new Uint8Array(0), signature: new Uint8Array(0), nonce: new Uint8Array(0) };
}

export const Identity: MessageFns<Identity> = {
  encode(message: Identity, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.publicKey.length !== 0) {
      writer.uint32(10).bytes(message.publicKey);
    }
    if (message.signature.length !== 0) {
      writer.uint32(18).bytes(message.signature);
    }
    if (message.nonce.length !== 0) {
      writer.uint32(26).bytes(message.nonce);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Identity {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIdentity();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.publicKey = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.signature = reader.bytes();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.nonce = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Identity {
    return {
      publicKey: isSet(object.publicKey) ? bytesFromBase64(object.publicKey) : new Uint8Array(0),
      signature: isSet(object.signature) ? bytesFromBase64(object.signature) : new Uint8Array(0),
      nonce: isSet(object.nonce) ? bytesFromBase64(object.nonce) : new Uint8Array(0),
    };
  },

  toJSON(message: Identity): unknown {
    const obj: any = {};
    if (message.publicKey.length !== 0) {
      obj.publicKey = base64FromBytes(message.publicKey);
    }
    if (message.signature.length !== 0) {
      obj.signature = base64FromBytes(message.signature);
    }
    if (message.nonce.length !== 0) {
      obj.nonce = base64FromBytes(message.nonce);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Identity>, I>>(base?: I): Identity {
    return Identity.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Identity>, I>>(object: I): Identity {
    const message = createBaseIdentity();
    message.publicKey = object.publicKey ?? new Uint8Array(0);
    message.signature = object.signature ?? new Uint8Array(0);
    message.nonce = object.nonce ?? new Uint8Array(0);
    return message;
  },
};

function createBaseMetadata(): Metadata {
  return { name: "", url: "", logoUrl: "", description: "" };
}

export const Metadata: MessageFns<Metadata> = {
  encode(message: Metadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.url !== "") {
      writer.uint32(18).string(message.url);
    }
    if (message.logoUrl !== "") {
      writer.uint32(26).string(message.logoUrl);
    }
    if (message.description !== "") {
      writer.uint32(34).string(message.description);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Metadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.url = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.logoUrl = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.description = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Metadata {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      url: isSet(object.url) ? globalThis.String(object.url) : "",
      logoUrl: isSet(object.logoUrl) ? globalThis.String(object.logoUrl) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
    };
  },

  toJSON(message: Metadata): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.url !== "") {
      obj.url = message.url;
    }
    if (message.logoUrl !== "") {
      obj.logoUrl = message.logoUrl;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Metadata>, I>>(base?: I): Metadata {
    return Metadata.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Metadata>, I>>(object: I): Metadata {
    const message = createBaseMetadata();
    message.name = object.name ?? "";
    message.url = object.url ?? "";
    message.logoUrl = object.logoUrl ?? "";
    message.description = object.description ?? "";
    return message;
  },
};

function createBaseRegisterClientRequest(): RegisterClientRequest {
  return { identity: undefined, metadata: undefined };
}

export const RegisterClientRequest: MessageFns<RegisterClientRequest> = {
  encode(message: RegisterClientRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.identity !== undefined) {
      Identity.encode(message.identity, writer.uint32(10).fork()).join();
    }
    if (message.metadata !== undefined) {
      Metadata.encode(message.metadata, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RegisterClientRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRegisterClientRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.identity = Identity.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.metadata = Metadata.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RegisterClientRequest {
    return {
      identity: isSet(object.identity) ? Identity.fromJSON(object.identity) : undefined,
      metadata: isSet(object.metadata) ? Metadata.fromJSON(object.metadata) : undefined,
    };
  },

  toJSON(message: RegisterClientRequest): unknown {
    const obj: any = {};
    if (message.identity !== undefined) {
      obj.identity = Identity.toJSON(message.identity);
    }
    if (message.metadata !== undefined) {
      obj.metadata = Metadata.toJSON(message.metadata);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RegisterClientRequest>, I>>(base?: I): RegisterClientRequest {
    return RegisterClientRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RegisterClientRequest>, I>>(object: I): RegisterClientRequest {
    const message = createBaseRegisterClientRequest();
    message.identity = (object.identity !== undefined && object.identity !== null)
      ? Identity.fromPartial(object.identity)
      : undefined;
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? Metadata.fromPartial(object.metadata)
      : undefined;
    return message;
  },
};

function createBaseRegisterClientResponse(): RegisterClientResponse {
  return { ok: false, invoice: "", message: "" };
}

export const RegisterClientResponse: MessageFns<RegisterClientResponse> = {
  encode(message: RegisterClientResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.ok !== false) {
      writer.uint32(8).bool(message.ok);
    }
    if (message.invoice !== "") {
      writer.uint32(18).string(message.invoice);
    }
    if (message.message !== "") {
      writer.uint32(26).string(message.message);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RegisterClientResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRegisterClientResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.ok = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.invoice = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.message = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RegisterClientResponse {
    return {
      ok: isSet(object.ok) ? globalThis.Boolean(object.ok) : false,
      invoice: isSet(object.invoice) ? globalThis.String(object.invoice) : "",
      message: isSet(object.message) ? globalThis.String(object.message) : "",
    };
  },

  toJSON(message: RegisterClientResponse): unknown {
    const obj: any = {};
    if (message.ok !== false) {
      obj.ok = message.ok;
    }
    if (message.invoice !== "") {
      obj.invoice = message.invoice;
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RegisterClientResponse>, I>>(base?: I): RegisterClientResponse {
    return RegisterClientResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RegisterClientResponse>, I>>(object: I): RegisterClientResponse {
    const message = createBaseRegisterClientResponse();
    message.ok = object.ok ?? false;
    message.invoice = object.invoice ?? "";
    message.message = object.message ?? "";
    return message;
  },
};

function createBaseRegisterProviderRequest(): RegisterProviderRequest {
  return { identity: undefined, metadata: undefined };
}

export const RegisterProviderRequest: MessageFns<RegisterProviderRequest> = {
  encode(message: RegisterProviderRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.identity !== undefined) {
      Identity.encode(message.identity, writer.uint32(10).fork()).join();
    }
    if (message.metadata !== undefined) {
      Metadata.encode(message.metadata, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RegisterProviderRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRegisterProviderRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.identity = Identity.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.metadata = Metadata.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RegisterProviderRequest {
    return {
      identity: isSet(object.identity) ? Identity.fromJSON(object.identity) : undefined,
      metadata: isSet(object.metadata) ? Metadata.fromJSON(object.metadata) : undefined,
    };
  },

  toJSON(message: RegisterProviderRequest): unknown {
    const obj: any = {};
    if (message.identity !== undefined) {
      obj.identity = Identity.toJSON(message.identity);
    }
    if (message.metadata !== undefined) {
      obj.metadata = Metadata.toJSON(message.metadata);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RegisterProviderRequest>, I>>(base?: I): RegisterProviderRequest {
    return RegisterProviderRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RegisterProviderRequest>, I>>(object: I): RegisterProviderRequest {
    const message = createBaseRegisterProviderRequest();
    message.identity = (object.identity !== undefined && object.identity !== null)
      ? Identity.fromPartial(object.identity)
      : undefined;
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? Metadata.fromPartial(object.metadata)
      : undefined;
    return message;
  },
};

function createBaseRegisterProviderResponse(): RegisterProviderResponse {
  return { ok: false, message: "" };
}

export const RegisterProviderResponse: MessageFns<RegisterProviderResponse> = {
  encode(message: RegisterProviderResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.ok !== false) {
      writer.uint32(8).bool(message.ok);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RegisterProviderResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRegisterProviderResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.ok = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RegisterProviderResponse {
    return {
      ok: isSet(object.ok) ? globalThis.Boolean(object.ok) : false,
      message: isSet(object.message) ? globalThis.String(object.message) : "",
    };
  },

  toJSON(message: RegisterProviderResponse): unknown {
    const obj: any = {};
    if (message.ok !== false) {
      obj.ok = message.ok;
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RegisterProviderResponse>, I>>(base?: I): RegisterProviderResponse {
    return RegisterProviderResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RegisterProviderResponse>, I>>(object: I): RegisterProviderResponse {
    const message = createBaseRegisterProviderResponse();
    message.ok = object.ok ?? false;
    message.message = object.message ?? "";
    return message;
  },
};

function createBaseStatusRequest(): StatusRequest {
  return { publicKey: "" };
}

export const StatusRequest: MessageFns<StatusRequest> = {
  encode(message: StatusRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.publicKey !== "") {
      writer.uint32(10).string(message.publicKey);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StatusRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStatusRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.publicKey = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StatusRequest {
    return { publicKey: isSet(object.publicKey) ? globalThis.String(object.publicKey) : "" };
  },

  toJSON(message: StatusRequest): unknown {
    const obj: any = {};
    if (message.publicKey !== "") {
      obj.publicKey = message.publicKey;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<StatusRequest>, I>>(base?: I): StatusRequest {
    return StatusRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<StatusRequest>, I>>(object: I): StatusRequest {
    const message = createBaseStatusRequest();
    message.publicKey = object.publicKey ?? "";
    return message;
  },
};

function createBaseStatusResponse(): StatusResponse {
  return { publicKey: "", role: 0, status: 0, metadata: undefined };
}

export const StatusResponse: MessageFns<StatusResponse> = {
  encode(message: StatusResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.publicKey !== "") {
      writer.uint32(10).string(message.publicKey);
    }
    if (message.role !== 0) {
      writer.uint32(16).int32(message.role);
    }
    if (message.status !== 0) {
      writer.uint32(24).int32(message.status);
    }
    if (message.metadata !== undefined) {
      Metadata.encode(message.metadata, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StatusResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStatusResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.publicKey = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.role = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.metadata = Metadata.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StatusResponse {
    return {
      publicKey: isSet(object.publicKey) ? globalThis.String(object.publicKey) : "",
      role: isSet(object.role) ? roleFromJSON(object.role) : 0,
      status: isSet(object.status) ? statusFromJSON(object.status) : 0,
      metadata: isSet(object.metadata) ? Metadata.fromJSON(object.metadata) : undefined,
    };
  },

  toJSON(message: StatusResponse): unknown {
    const obj: any = {};
    if (message.publicKey !== "") {
      obj.publicKey = message.publicKey;
    }
    if (message.role !== 0) {
      obj.role = roleToJSON(message.role);
    }
    if (message.status !== 0) {
      obj.status = statusToJSON(message.status);
    }
    if (message.metadata !== undefined) {
      obj.metadata = Metadata.toJSON(message.metadata);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<StatusResponse>, I>>(base?: I): StatusResponse {
    return StatusResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<StatusResponse>, I>>(object: I): StatusResponse {
    const message = createBaseStatusResponse();
    message.publicKey = object.publicKey ?? "";
    message.role = object.role ?? 0;
    message.status = object.status ?? 0;
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? Metadata.fromPartial(object.metadata)
      : undefined;
    return message;
  },
};

function createBaseConnectionRequest(): ConnectionRequest {
  return { identity: undefined };
}

export const ConnectionRequest: MessageFns<ConnectionRequest> = {
  encode(message: ConnectionRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.identity !== undefined) {
      Identity.encode(message.identity, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ConnectionRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseConnectionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.identity = Identity.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ConnectionRequest {
    return { identity: isSet(object.identity) ? Identity.fromJSON(object.identity) : undefined };
  },

  toJSON(message: ConnectionRequest): unknown {
    const obj: any = {};
    if (message.identity !== undefined) {
      obj.identity = Identity.toJSON(message.identity);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ConnectionRequest>, I>>(base?: I): ConnectionRequest {
    return ConnectionRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ConnectionRequest>, I>>(object: I): ConnectionRequest {
    const message = createBaseConnectionRequest();
    message.identity = (object.identity !== undefined && object.identity !== null)
      ? Identity.fromPartial(object.identity)
      : undefined;
    return message;
  },
};

function createBaseConnectionResponse(): ConnectionResponse {
  return { ok: false, message: "" };
}

export const ConnectionResponse: MessageFns<ConnectionResponse> = {
  encode(message: ConnectionResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.ok !== false) {
      writer.uint32(8).bool(message.ok);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ConnectionResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseConnectionResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.ok = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ConnectionResponse {
    return {
      ok: isSet(object.ok) ? globalThis.Boolean(object.ok) : false,
      message: isSet(object.message) ? globalThis.String(object.message) : "",
    };
  },

  toJSON(message: ConnectionResponse): unknown {
    const obj: any = {};
    if (message.ok !== false) {
      obj.ok = message.ok;
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ConnectionResponse>, I>>(base?: I): ConnectionResponse {
    return ConnectionResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ConnectionResponse>, I>>(object: I): ConnectionResponse {
    const message = createBaseConnectionResponse();
    message.ok = object.ok ?? false;
    message.message = object.message ?? "";
    return message;
  },
};

function createBasePricing(): Pricing {
  return { satsPerTokenIn: 0, satsPerTokenOut: 0, satsPerPixel: 0 };
}

export const Pricing: MessageFns<Pricing> = {
  encode(message: Pricing, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.satsPerTokenIn !== 0) {
      writer.uint32(13).float(message.satsPerTokenIn);
    }
    if (message.satsPerTokenOut !== 0) {
      writer.uint32(21).float(message.satsPerTokenOut);
    }
    if (message.satsPerPixel !== 0) {
      writer.uint32(29).float(message.satsPerPixel);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Pricing {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePricing();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 13) {
            break;
          }

          message.satsPerTokenIn = reader.float();
          continue;
        }
        case 2: {
          if (tag !== 21) {
            break;
          }

          message.satsPerTokenOut = reader.float();
          continue;
        }
        case 3: {
          if (tag !== 29) {
            break;
          }

          message.satsPerPixel = reader.float();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Pricing {
    return {
      satsPerTokenIn: isSet(object.satsPerTokenIn) ? globalThis.Number(object.satsPerTokenIn) : 0,
      satsPerTokenOut: isSet(object.satsPerTokenOut) ? globalThis.Number(object.satsPerTokenOut) : 0,
      satsPerPixel: isSet(object.satsPerPixel) ? globalThis.Number(object.satsPerPixel) : 0,
    };
  },

  toJSON(message: Pricing): unknown {
    const obj: any = {};
    if (message.satsPerTokenIn !== 0) {
      obj.satsPerTokenIn = message.satsPerTokenIn;
    }
    if (message.satsPerTokenOut !== 0) {
      obj.satsPerTokenOut = message.satsPerTokenOut;
    }
    if (message.satsPerPixel !== 0) {
      obj.satsPerPixel = message.satsPerPixel;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Pricing>, I>>(base?: I): Pricing {
    return Pricing.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Pricing>, I>>(object: I): Pricing {
    const message = createBasePricing();
    message.satsPerTokenIn = object.satsPerTokenIn ?? 0;
    message.satsPerTokenOut = object.satsPerTokenOut ?? 0;
    message.satsPerPixel = object.satsPerPixel ?? 0;
    return message;
  },
};

function createBaseRegisterModelRequest(): RegisterModelRequest {
  return { alias: "", tier: 0, pricing: undefined, flags: [] };
}

export const RegisterModelRequest: MessageFns<RegisterModelRequest> = {
  encode(message: RegisterModelRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.alias !== "") {
      writer.uint32(10).string(message.alias);
    }
    if (message.tier !== 0) {
      writer.uint32(16).int32(message.tier);
    }
    if (message.pricing !== undefined) {
      Pricing.encode(message.pricing, writer.uint32(26).fork()).join();
    }
    writer.uint32(34).fork();
    for (const v of message.flags) {
      writer.int32(v);
    }
    writer.join();
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RegisterModelRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRegisterModelRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.alias = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.tier = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.pricing = Pricing.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag === 32) {
            message.flags.push(reader.int32() as any);

            continue;
          }

          if (tag === 34) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.flags.push(reader.int32() as any);
            }

            continue;
          }

          break;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RegisterModelRequest {
    return {
      alias: isSet(object.alias) ? globalThis.String(object.alias) : "",
      tier: isSet(object.tier) ? modelTierFromJSON(object.tier) : 0,
      pricing: isSet(object.pricing) ? Pricing.fromJSON(object.pricing) : undefined,
      flags: globalThis.Array.isArray(object?.flags) ? object.flags.map((e: any) => featureFlagFromJSON(e)) : [],
    };
  },

  toJSON(message: RegisterModelRequest): unknown {
    const obj: any = {};
    if (message.alias !== "") {
      obj.alias = message.alias;
    }
    if (message.tier !== 0) {
      obj.tier = modelTierToJSON(message.tier);
    }
    if (message.pricing !== undefined) {
      obj.pricing = Pricing.toJSON(message.pricing);
    }
    if (message.flags?.length) {
      obj.flags = message.flags.map((e) => featureFlagToJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RegisterModelRequest>, I>>(base?: I): RegisterModelRequest {
    return RegisterModelRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RegisterModelRequest>, I>>(object: I): RegisterModelRequest {
    const message = createBaseRegisterModelRequest();
    message.alias = object.alias ?? "";
    message.tier = object.tier ?? 0;
    message.pricing = (object.pricing !== undefined && object.pricing !== null)
      ? Pricing.fromPartial(object.pricing)
      : undefined;
    message.flags = object.flags?.map((e) => e) || [];
    return message;
  },
};

function createBaseRegisterModelResponse(): RegisterModelResponse {
  return { ok: false, message: "" };
}

export const RegisterModelResponse: MessageFns<RegisterModelResponse> = {
  encode(message: RegisterModelResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.ok !== false) {
      writer.uint32(8).bool(message.ok);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RegisterModelResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRegisterModelResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.ok = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RegisterModelResponse {
    return {
      ok: isSet(object.ok) ? globalThis.Boolean(object.ok) : false,
      message: isSet(object.message) ? globalThis.String(object.message) : "",
    };
  },

  toJSON(message: RegisterModelResponse): unknown {
    const obj: any = {};
    if (message.ok !== false) {
      obj.ok = message.ok;
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RegisterModelResponse>, I>>(base?: I): RegisterModelResponse {
    return RegisterModelResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RegisterModelResponse>, I>>(object: I): RegisterModelResponse {
    const message = createBaseRegisterModelResponse();
    message.ok = object.ok ?? false;
    message.message = object.message ?? "";
    return message;
  },
};

function createBaseChatCompletionMessageParts(): ChatCompletionMessageParts {
  return { parts: [] };
}

export const ChatCompletionMessageParts: MessageFns<ChatCompletionMessageParts> = {
  encode(message: ChatCompletionMessageParts, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.parts) {
      ChatCompletionMessagePart.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ChatCompletionMessageParts {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseChatCompletionMessageParts();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.parts.push(ChatCompletionMessagePart.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ChatCompletionMessageParts {
    return {
      parts: globalThis.Array.isArray(object?.parts)
        ? object.parts.map((e: any) => ChatCompletionMessagePart.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ChatCompletionMessageParts): unknown {
    const obj: any = {};
    if (message.parts?.length) {
      obj.parts = message.parts.map((e) => ChatCompletionMessagePart.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ChatCompletionMessageParts>, I>>(base?: I): ChatCompletionMessageParts {
    return ChatCompletionMessageParts.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ChatCompletionMessageParts>, I>>(object: I): ChatCompletionMessageParts {
    const message = createBaseChatCompletionMessageParts();
    message.parts = object.parts?.map((e) => ChatCompletionMessagePart.fromPartial(e)) || [];
    return message;
  },
};

function createBaseChatCompletionMessagePart(): ChatCompletionMessagePart {
  return { type: "", text: "", imageUrl: undefined };
}

export const ChatCompletionMessagePart: MessageFns<ChatCompletionMessagePart> = {
  encode(message: ChatCompletionMessagePart, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.type !== "") {
      writer.uint32(10).string(message.type);
    }
    if (message.text !== "") {
      writer.uint32(18).string(message.text);
    }
    if (message.imageUrl !== undefined) {
      ImageURL.encode(message.imageUrl, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ChatCompletionMessagePart {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseChatCompletionMessagePart();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.type = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.text = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.imageUrl = ImageURL.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ChatCompletionMessagePart {
    return {
      type: isSet(object.type) ? globalThis.String(object.type) : "",
      text: isSet(object.text) ? globalThis.String(object.text) : "",
      imageUrl: isSet(object.imageUrl) ? ImageURL.fromJSON(object.imageUrl) : undefined,
    };
  },

  toJSON(message: ChatCompletionMessagePart): unknown {
    const obj: any = {};
    if (message.type !== "") {
      obj.type = message.type;
    }
    if (message.text !== "") {
      obj.text = message.text;
    }
    if (message.imageUrl !== undefined) {
      obj.imageUrl = ImageURL.toJSON(message.imageUrl);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ChatCompletionMessagePart>, I>>(base?: I): ChatCompletionMessagePart {
    return ChatCompletionMessagePart.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ChatCompletionMessagePart>, I>>(object: I): ChatCompletionMessagePart {
    const message = createBaseChatCompletionMessagePart();
    message.type = object.type ?? "";
    message.text = object.text ?? "";
    message.imageUrl = (object.imageUrl !== undefined && object.imageUrl !== null)
      ? ImageURL.fromPartial(object.imageUrl)
      : undefined;
    return message;
  },
};

function createBaseImageURL(): ImageURL {
  return { url: "", detail: "" };
}

export const ImageURL: MessageFns<ImageURL> = {
  encode(message: ImageURL, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.url !== "") {
      writer.uint32(10).string(message.url);
    }
    if (message.detail !== "") {
      writer.uint32(18).string(message.detail);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ImageURL {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseImageURL();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.url = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.detail = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ImageURL {
    return {
      url: isSet(object.url) ? globalThis.String(object.url) : "",
      detail: isSet(object.detail) ? globalThis.String(object.detail) : "",
    };
  },

  toJSON(message: ImageURL): unknown {
    const obj: any = {};
    if (message.url !== "") {
      obj.url = message.url;
    }
    if (message.detail !== "") {
      obj.detail = message.detail;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ImageURL>, I>>(base?: I): ImageURL {
    return ImageURL.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ImageURL>, I>>(object: I): ImageURL {
    const message = createBaseImageURL();
    message.url = object.url ?? "";
    message.detail = object.detail ?? "";
    return message;
  },
};

function createBaseChatCompletionMessage(): ChatCompletionMessage {
  return { role: "", content: undefined, name: "", toolCallId: "" };
}

export const ChatCompletionMessage: MessageFns<ChatCompletionMessage> = {
  encode(message: ChatCompletionMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.role !== "") {
      writer.uint32(10).string(message.role);
    }
    switch (message.content?.$case) {
      case "text":
        writer.uint32(18).string(message.content.text);
        break;
      case "multi":
        ChatCompletionMessageParts.encode(message.content.multi, writer.uint32(26).fork()).join();
        break;
    }
    if (message.name !== "") {
      writer.uint32(34).string(message.name);
    }
    if (message.toolCallId !== "") {
      writer.uint32(42).string(message.toolCallId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ChatCompletionMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseChatCompletionMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.role = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.content = { $case: "text", text: reader.string() };
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.content = { $case: "multi", multi: ChatCompletionMessageParts.decode(reader, reader.uint32()) };
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.toolCallId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ChatCompletionMessage {
    return {
      role: isSet(object.role) ? globalThis.String(object.role) : "",
      content: isSet(object.text)
        ? { $case: "text", text: globalThis.String(object.text) }
        : isSet(object.multi)
        ? { $case: "multi", multi: ChatCompletionMessageParts.fromJSON(object.multi) }
        : undefined,
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      toolCallId: isSet(object.toolCallId) ? globalThis.String(object.toolCallId) : "",
    };
  },

  toJSON(message: ChatCompletionMessage): unknown {
    const obj: any = {};
    if (message.role !== "") {
      obj.role = message.role;
    }
    if (message.content?.$case === "text") {
      obj.text = message.content.text;
    } else if (message.content?.$case === "multi") {
      obj.multi = ChatCompletionMessageParts.toJSON(message.content.multi);
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.toolCallId !== "") {
      obj.toolCallId = message.toolCallId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ChatCompletionMessage>, I>>(base?: I): ChatCompletionMessage {
    return ChatCompletionMessage.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ChatCompletionMessage>, I>>(object: I): ChatCompletionMessage {
    const message = createBaseChatCompletionMessage();
    message.role = object.role ?? "";
    switch (object.content?.$case) {
      case "text": {
        if (object.content?.text !== undefined && object.content?.text !== null) {
          message.content = { $case: "text", text: object.content.text };
        }
        break;
      }
      case "multi": {
        if (object.content?.multi !== undefined && object.content?.multi !== null) {
          message.content = { $case: "multi", multi: ChatCompletionMessageParts.fromPartial(object.content.multi) };
        }
        break;
      }
    }
    message.name = object.name ?? "";
    message.toolCallId = object.toolCallId ?? "";
    return message;
  },
};

function createBaseChatCompletionRequest(): ChatCompletionRequest {
  return {
    requestId: 0,
    seed: 0,
    maxTokens: 0,
    temperature: 0,
    tierSelector: "",
    flags: [],
    responseFormat: undefined,
    tools: [],
    messages: [],
  };
}

export const ChatCompletionRequest: MessageFns<ChatCompletionRequest> = {
  encode(message: ChatCompletionRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.requestId !== 0) {
      writer.uint32(8).int64(message.requestId);
    }
    if (message.seed !== 0) {
      writer.uint32(16).int32(message.seed);
    }
    if (message.maxTokens !== 0) {
      writer.uint32(24).int32(message.maxTokens);
    }
    if (message.temperature !== 0) {
      writer.uint32(37).float(message.temperature);
    }
    if (message.tierSelector !== "") {
      writer.uint32(42).string(message.tierSelector);
    }
    writer.uint32(50).fork();
    for (const v of message.flags) {
      writer.int32(v);
    }
    writer.join();
    if (message.responseFormat !== undefined) {
      ResponseFormat.encode(message.responseFormat, writer.uint32(58).fork()).join();
    }
    for (const v of message.tools) {
      Tool.encode(v!, writer.uint32(66).fork()).join();
    }
    for (const v of message.messages) {
      ChatCompletionMessage.encode(v!, writer.uint32(74).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ChatCompletionRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseChatCompletionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.requestId = longToNumber(reader.int64());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.seed = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.maxTokens = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 37) {
            break;
          }

          message.temperature = reader.float();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.tierSelector = reader.string();
          continue;
        }
        case 6: {
          if (tag === 48) {
            message.flags.push(reader.int32() as any);

            continue;
          }

          if (tag === 50) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.flags.push(reader.int32() as any);
            }

            continue;
          }

          break;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.responseFormat = ResponseFormat.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.tools.push(Tool.decode(reader, reader.uint32()));
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.messages.push(ChatCompletionMessage.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ChatCompletionRequest {
    return {
      requestId: isSet(object.requestId) ? globalThis.Number(object.requestId) : 0,
      seed: isSet(object.seed) ? globalThis.Number(object.seed) : 0,
      maxTokens: isSet(object.maxTokens) ? globalThis.Number(object.maxTokens) : 0,
      temperature: isSet(object.temperature) ? globalThis.Number(object.temperature) : 0,
      tierSelector: isSet(object.tierSelector) ? globalThis.String(object.tierSelector) : "",
      flags: globalThis.Array.isArray(object?.flags) ? object.flags.map((e: any) => featureFlagFromJSON(e)) : [],
      responseFormat: isSet(object.responseFormat) ? ResponseFormat.fromJSON(object.responseFormat) : undefined,
      tools: globalThis.Array.isArray(object?.tools) ? object.tools.map((e: any) => Tool.fromJSON(e)) : [],
      messages: globalThis.Array.isArray(object?.messages)
        ? object.messages.map((e: any) => ChatCompletionMessage.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ChatCompletionRequest): unknown {
    const obj: any = {};
    if (message.requestId !== 0) {
      obj.requestId = Math.round(message.requestId);
    }
    if (message.seed !== 0) {
      obj.seed = Math.round(message.seed);
    }
    if (message.maxTokens !== 0) {
      obj.maxTokens = Math.round(message.maxTokens);
    }
    if (message.temperature !== 0) {
      obj.temperature = message.temperature;
    }
    if (message.tierSelector !== "") {
      obj.tierSelector = message.tierSelector;
    }
    if (message.flags?.length) {
      obj.flags = message.flags.map((e) => featureFlagToJSON(e));
    }
    if (message.responseFormat !== undefined) {
      obj.responseFormat = ResponseFormat.toJSON(message.responseFormat);
    }
    if (message.tools?.length) {
      obj.tools = message.tools.map((e) => Tool.toJSON(e));
    }
    if (message.messages?.length) {
      obj.messages = message.messages.map((e) => ChatCompletionMessage.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ChatCompletionRequest>, I>>(base?: I): ChatCompletionRequest {
    return ChatCompletionRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ChatCompletionRequest>, I>>(object: I): ChatCompletionRequest {
    const message = createBaseChatCompletionRequest();
    message.requestId = object.requestId ?? 0;
    message.seed = object.seed ?? 0;
    message.maxTokens = object.maxTokens ?? 0;
    message.temperature = object.temperature ?? 0;
    message.tierSelector = object.tierSelector ?? "";
    message.flags = object.flags?.map((e) => e) || [];
    message.responseFormat = (object.responseFormat !== undefined && object.responseFormat !== null)
      ? ResponseFormat.fromPartial(object.responseFormat)
      : undefined;
    message.tools = object.tools?.map((e) => Tool.fromPartial(e)) || [];
    message.messages = object.messages?.map((e) => ChatCompletionMessage.fromPartial(e)) || [];
    return message;
  },
};

function createBaseResponseFormat(): ResponseFormat {
  return { type: "" };
}

export const ResponseFormat: MessageFns<ResponseFormat> = {
  encode(message: ResponseFormat, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.type !== "") {
      writer.uint32(10).string(message.type);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ResponseFormat {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseResponseFormat();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.type = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ResponseFormat {
    return { type: isSet(object.type) ? globalThis.String(object.type) : "" };
  },

  toJSON(message: ResponseFormat): unknown {
    const obj: any = {};
    if (message.type !== "") {
      obj.type = message.type;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ResponseFormat>, I>>(base?: I): ResponseFormat {
    return ResponseFormat.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ResponseFormat>, I>>(object: I): ResponseFormat {
    const message = createBaseResponseFormat();
    message.type = object.type ?? "";
    return message;
  },
};

function createBaseTool(): Tool {
  return { type: "", function: undefined };
}

export const Tool: MessageFns<Tool> = {
  encode(message: Tool, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.type !== "") {
      writer.uint32(10).string(message.type);
    }
    if (message.function !== undefined) {
      FunctionDescription.encode(message.function, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Tool {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTool();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.type = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.function = FunctionDescription.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Tool {
    return {
      type: isSet(object.type) ? globalThis.String(object.type) : "",
      function: isSet(object.function) ? FunctionDescription.fromJSON(object.function) : undefined,
    };
  },

  toJSON(message: Tool): unknown {
    const obj: any = {};
    if (message.type !== "") {
      obj.type = message.type;
    }
    if (message.function !== undefined) {
      obj.function = FunctionDescription.toJSON(message.function);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Tool>, I>>(base?: I): Tool {
    return Tool.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Tool>, I>>(object: I): Tool {
    const message = createBaseTool();
    message.type = object.type ?? "";
    message.function = (object.function !== undefined && object.function !== null)
      ? FunctionDescription.fromPartial(object.function)
      : undefined;
    return message;
  },
};

function createBaseFunctionDescription(): FunctionDescription {
  return { name: "", description: "", parameters: "" };
}

export const FunctionDescription: MessageFns<FunctionDescription> = {
  encode(message: FunctionDescription, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.description !== "") {
      writer.uint32(18).string(message.description);
    }
    if (message.parameters !== "") {
      writer.uint32(26).string(message.parameters);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FunctionDescription {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFunctionDescription();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.parameters = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FunctionDescription {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      parameters: isSet(object.parameters) ? globalThis.String(object.parameters) : "",
    };
  },

  toJSON(message: FunctionDescription): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.parameters !== "") {
      obj.parameters = message.parameters;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<FunctionDescription>, I>>(base?: I): FunctionDescription {
    return FunctionDescription.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<FunctionDescription>, I>>(object: I): FunctionDescription {
    const message = createBaseFunctionDescription();
    message.name = object.name ?? "";
    message.description = object.description ?? "";
    message.parameters = object.parameters ?? "";
    return message;
  },
};

function createBaseToolCall(): ToolCall {
  return { id: "", type: "", function: undefined };
}

export const ToolCall: MessageFns<ToolCall> = {
  encode(message: ToolCall, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.type !== "") {
      writer.uint32(18).string(message.type);
    }
    if (message.function !== undefined) {
      ToolCallFunction.encode(message.function, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ToolCall {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseToolCall();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.type = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.function = ToolCallFunction.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ToolCall {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      type: isSet(object.type) ? globalThis.String(object.type) : "",
      function: isSet(object.function) ? ToolCallFunction.fromJSON(object.function) : undefined,
    };
  },

  toJSON(message: ToolCall): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.type !== "") {
      obj.type = message.type;
    }
    if (message.function !== undefined) {
      obj.function = ToolCallFunction.toJSON(message.function);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ToolCall>, I>>(base?: I): ToolCall {
    return ToolCall.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ToolCall>, I>>(object: I): ToolCall {
    const message = createBaseToolCall();
    message.id = object.id ?? "";
    message.type = object.type ?? "";
    message.function = (object.function !== undefined && object.function !== null)
      ? ToolCallFunction.fromPartial(object.function)
      : undefined;
    return message;
  },
};

function createBaseToolCallFunction(): ToolCallFunction {
  return { name: "", arguments: "" };
}

export const ToolCallFunction: MessageFns<ToolCallFunction> = {
  encode(message: ToolCallFunction, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.arguments !== "") {
      writer.uint32(18).string(message.arguments);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ToolCallFunction {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseToolCallFunction();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.arguments = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ToolCallFunction {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      arguments: isSet(object.arguments) ? globalThis.String(object.arguments) : "",
    };
  },

  toJSON(message: ToolCallFunction): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.arguments !== "") {
      obj.arguments = message.arguments;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ToolCallFunction>, I>>(base?: I): ToolCallFunction {
    return ToolCallFunction.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ToolCallFunction>, I>>(object: I): ToolCallFunction {
    const message = createBaseToolCallFunction();
    message.name = object.name ?? "";
    message.arguments = object.arguments ?? "";
    return message;
  },
};

function createBaseChatCompletionPartial(): ChatCompletionPartial {
  return { requestId: 0, index: 0, message: "", toolCalls: [], isComplete: false };
}

export const ChatCompletionPartial: MessageFns<ChatCompletionPartial> = {
  encode(message: ChatCompletionPartial, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.requestId !== 0) {
      writer.uint32(8).int64(message.requestId);
    }
    if (message.index !== 0) {
      writer.uint32(16).int64(message.index);
    }
    if (message.message !== "") {
      writer.uint32(26).string(message.message);
    }
    for (const v of message.toolCalls) {
      ToolCall.encode(v!, writer.uint32(34).fork()).join();
    }
    if (message.isComplete !== false) {
      writer.uint32(40).bool(message.isComplete);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ChatCompletionPartial {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseChatCompletionPartial();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.requestId = longToNumber(reader.int64());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.index = longToNumber(reader.int64());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.message = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.toolCalls.push(ToolCall.decode(reader, reader.uint32()));
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.isComplete = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ChatCompletionPartial {
    return {
      requestId: isSet(object.requestId) ? globalThis.Number(object.requestId) : 0,
      index: isSet(object.index) ? globalThis.Number(object.index) : 0,
      message: isSet(object.message) ? globalThis.String(object.message) : "",
      toolCalls: globalThis.Array.isArray(object?.toolCalls)
        ? object.toolCalls.map((e: any) => ToolCall.fromJSON(e))
        : [],
      isComplete: isSet(object.isComplete) ? globalThis.Boolean(object.isComplete) : false,
    };
  },

  toJSON(message: ChatCompletionPartial): unknown {
    const obj: any = {};
    if (message.requestId !== 0) {
      obj.requestId = Math.round(message.requestId);
    }
    if (message.index !== 0) {
      obj.index = Math.round(message.index);
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    if (message.toolCalls?.length) {
      obj.toolCalls = message.toolCalls.map((e) => ToolCall.toJSON(e));
    }
    if (message.isComplete !== false) {
      obj.isComplete = message.isComplete;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ChatCompletionPartial>, I>>(base?: I): ChatCompletionPartial {
    return ChatCompletionPartial.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ChatCompletionPartial>, I>>(object: I): ChatCompletionPartial {
    const message = createBaseChatCompletionPartial();
    message.requestId = object.requestId ?? 0;
    message.index = object.index ?? 0;
    message.message = object.message ?? "";
    message.toolCalls = object.toolCalls?.map((e) => ToolCall.fromPartial(e)) || [];
    message.isComplete = object.isComplete ?? false;
    return message;
  },
};

function createBaseChatCompletionComplete(): ChatCompletionComplete {
  return { requestId: 0, invoice: "", promptTokens: 0, completionTokens: 0 };
}

export const ChatCompletionComplete: MessageFns<ChatCompletionComplete> = {
  encode(message: ChatCompletionComplete, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.requestId !== 0) {
      writer.uint32(8).int64(message.requestId);
    }
    if (message.invoice !== "") {
      writer.uint32(18).string(message.invoice);
    }
    if (message.promptTokens !== 0) {
      writer.uint32(24).int64(message.promptTokens);
    }
    if (message.completionTokens !== 0) {
      writer.uint32(32).int64(message.completionTokens);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ChatCompletionComplete {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseChatCompletionComplete();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.requestId = longToNumber(reader.int64());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.invoice = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.promptTokens = longToNumber(reader.int64());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.completionTokens = longToNumber(reader.int64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ChatCompletionComplete {
    return {
      requestId: isSet(object.requestId) ? globalThis.Number(object.requestId) : 0,
      invoice: isSet(object.invoice) ? globalThis.String(object.invoice) : "",
      promptTokens: isSet(object.promptTokens) ? globalThis.Number(object.promptTokens) : 0,
      completionTokens: isSet(object.completionTokens) ? globalThis.Number(object.completionTokens) : 0,
    };
  },

  toJSON(message: ChatCompletionComplete): unknown {
    const obj: any = {};
    if (message.requestId !== 0) {
      obj.requestId = Math.round(message.requestId);
    }
    if (message.invoice !== "") {
      obj.invoice = message.invoice;
    }
    if (message.promptTokens !== 0) {
      obj.promptTokens = Math.round(message.promptTokens);
    }
    if (message.completionTokens !== 0) {
      obj.completionTokens = Math.round(message.completionTokens);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ChatCompletionComplete>, I>>(base?: I): ChatCompletionComplete {
    return ChatCompletionComplete.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ChatCompletionComplete>, I>>(object: I): ChatCompletionComplete {
    const message = createBaseChatCompletionComplete();
    message.requestId = object.requestId ?? 0;
    message.invoice = object.invoice ?? "";
    message.promptTokens = object.promptTokens ?? 0;
    message.completionTokens = object.completionTokens ?? 0;
    return message;
  },
};

function createBaseRevealPreimage(): RevealPreimage {
  return { requestId: 0, preimage: "" };
}

export const RevealPreimage: MessageFns<RevealPreimage> = {
  encode(message: RevealPreimage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.requestId !== 0) {
      writer.uint32(8).int64(message.requestId);
    }
    if (message.preimage !== "") {
      writer.uint32(18).string(message.preimage);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RevealPreimage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRevealPreimage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.requestId = longToNumber(reader.int64());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.preimage = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RevealPreimage {
    return {
      requestId: isSet(object.requestId) ? globalThis.Number(object.requestId) : 0,
      preimage: isSet(object.preimage) ? globalThis.String(object.preimage) : "",
    };
  },

  toJSON(message: RevealPreimage): unknown {
    const obj: any = {};
    if (message.requestId !== 0) {
      obj.requestId = Math.round(message.requestId);
    }
    if (message.preimage !== "") {
      obj.preimage = message.preimage;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RevealPreimage>, I>>(base?: I): RevealPreimage {
    return RevealPreimage.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RevealPreimage>, I>>(object: I): RevealPreimage {
    const message = createBaseRevealPreimage();
    message.requestId = object.requestId ?? 0;
    message.preimage = object.preimage ?? "";
    return message;
  },
};

function createBaseRelayError(): RelayError {
  return { requestId: 0, message: "" };
}

export const RelayError: MessageFns<RelayError> = {
  encode(message: RelayError, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.requestId !== 0) {
      writer.uint32(8).int64(message.requestId);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RelayError {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRelayError();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.requestId = longToNumber(reader.int64());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RelayError {
    return {
      requestId: isSet(object.requestId) ? globalThis.Number(object.requestId) : 0,
      message: isSet(object.message) ? globalThis.String(object.message) : "",
    };
  },

  toJSON(message: RelayError): unknown {
    const obj: any = {};
    if (message.requestId !== 0) {
      obj.requestId = Math.round(message.requestId);
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RelayError>, I>>(base?: I): RelayError {
    return RelayError.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RelayError>, I>>(object: I): RelayError {
    const message = createBaseRelayError();
    message.requestId = object.requestId ?? 0;
    message.message = object.message ?? "";
    return message;
  },
};

function createBaseMessageEnvelope(): MessageEnvelope {
  return { payload: undefined };
}

export const MessageEnvelope: MessageFns<MessageEnvelope> = {
  encode(message: MessageEnvelope, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    switch (message.payload?.$case) {
      case "registerClientRequest":
        RegisterClientRequest.encode(message.payload.registerClientRequest, writer.uint32(10).fork()).join();
        break;
      case "registerClientResponse":
        RegisterClientResponse.encode(message.payload.registerClientResponse, writer.uint32(18).fork()).join();
        break;
      case "registerProviderRequest":
        RegisterProviderRequest.encode(message.payload.registerProviderRequest, writer.uint32(26).fork()).join();
        break;
      case "registerProviderResponse":
        RegisterProviderResponse.encode(message.payload.registerProviderResponse, writer.uint32(34).fork()).join();
        break;
      case "statusRequest":
        StatusRequest.encode(message.payload.statusRequest, writer.uint32(42).fork()).join();
        break;
      case "statusResponse":
        StatusResponse.encode(message.payload.statusResponse, writer.uint32(50).fork()).join();
        break;
      case "connectionRequest":
        ConnectionRequest.encode(message.payload.connectionRequest, writer.uint32(58).fork()).join();
        break;
      case "connectionResponse":
        ConnectionResponse.encode(message.payload.connectionResponse, writer.uint32(66).fork()).join();
        break;
      case "registerModelRequest":
        RegisterModelRequest.encode(message.payload.registerModelRequest, writer.uint32(74).fork()).join();
        break;
      case "registerModelResponse":
        RegisterModelResponse.encode(message.payload.registerModelResponse, writer.uint32(82).fork()).join();
        break;
      case "chatCompletionRequest":
        ChatCompletionRequest.encode(message.payload.chatCompletionRequest, writer.uint32(90).fork()).join();
        break;
      case "chatCompletionPartial":
        ChatCompletionPartial.encode(message.payload.chatCompletionPartial, writer.uint32(98).fork()).join();
        break;
      case "chatCompletionComplete":
        ChatCompletionComplete.encode(message.payload.chatCompletionComplete, writer.uint32(106).fork()).join();
        break;
      case "revealPreimage":
        RevealPreimage.encode(message.payload.revealPreimage, writer.uint32(114).fork()).join();
        break;
      case "relayError":
        RelayError.encode(message.payload.relayError, writer.uint32(122).fork()).join();
        break;
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MessageEnvelope {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMessageEnvelope();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.payload = {
            $case: "registerClientRequest",
            registerClientRequest: RegisterClientRequest.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.payload = {
            $case: "registerClientResponse",
            registerClientResponse: RegisterClientResponse.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.payload = {
            $case: "registerProviderRequest",
            registerProviderRequest: RegisterProviderRequest.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.payload = {
            $case: "registerProviderResponse",
            registerProviderResponse: RegisterProviderResponse.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.payload = { $case: "statusRequest", statusRequest: StatusRequest.decode(reader, reader.uint32()) };
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.payload = { $case: "statusResponse", statusResponse: StatusResponse.decode(reader, reader.uint32()) };
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.payload = {
            $case: "connectionRequest",
            connectionRequest: ConnectionRequest.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.payload = {
            $case: "connectionResponse",
            connectionResponse: ConnectionResponse.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.payload = {
            $case: "registerModelRequest",
            registerModelRequest: RegisterModelRequest.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.payload = {
            $case: "registerModelResponse",
            registerModelResponse: RegisterModelResponse.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.payload = {
            $case: "chatCompletionRequest",
            chatCompletionRequest: ChatCompletionRequest.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.payload = {
            $case: "chatCompletionPartial",
            chatCompletionPartial: ChatCompletionPartial.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.payload = {
            $case: "chatCompletionComplete",
            chatCompletionComplete: ChatCompletionComplete.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.payload = { $case: "revealPreimage", revealPreimage: RevealPreimage.decode(reader, reader.uint32()) };
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.payload = { $case: "relayError", relayError: RelayError.decode(reader, reader.uint32()) };
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MessageEnvelope {
    return {
      payload: isSet(object.registerClientRequest)
        ? {
          $case: "registerClientRequest",
          registerClientRequest: RegisterClientRequest.fromJSON(object.registerClientRequest),
        }
        : isSet(object.registerClientResponse)
        ? {
          $case: "registerClientResponse",
          registerClientResponse: RegisterClientResponse.fromJSON(object.registerClientResponse),
        }
        : isSet(object.registerProviderRequest)
        ? {
          $case: "registerProviderRequest",
          registerProviderRequest: RegisterProviderRequest.fromJSON(object.registerProviderRequest),
        }
        : isSet(object.registerProviderResponse)
        ? {
          $case: "registerProviderResponse",
          registerProviderResponse: RegisterProviderResponse.fromJSON(object.registerProviderResponse),
        }
        : isSet(object.statusRequest)
        ? { $case: "statusRequest", statusRequest: StatusRequest.fromJSON(object.statusRequest) }
        : isSet(object.statusResponse)
        ? { $case: "statusResponse", statusResponse: StatusResponse.fromJSON(object.statusResponse) }
        : isSet(object.connectionRequest)
        ? { $case: "connectionRequest", connectionRequest: ConnectionRequest.fromJSON(object.connectionRequest) }
        : isSet(object.connectionResponse)
        ? { $case: "connectionResponse", connectionResponse: ConnectionResponse.fromJSON(object.connectionResponse) }
        : isSet(object.registerModelRequest)
        ? {
          $case: "registerModelRequest",
          registerModelRequest: RegisterModelRequest.fromJSON(object.registerModelRequest),
        }
        : isSet(object.registerModelResponse)
        ? {
          $case: "registerModelResponse",
          registerModelResponse: RegisterModelResponse.fromJSON(object.registerModelResponse),
        }
        : isSet(object.chatCompletionRequest)
        ? {
          $case: "chatCompletionRequest",
          chatCompletionRequest: ChatCompletionRequest.fromJSON(object.chatCompletionRequest),
        }
        : isSet(object.chatCompletionPartial)
        ? {
          $case: "chatCompletionPartial",
          chatCompletionPartial: ChatCompletionPartial.fromJSON(object.chatCompletionPartial),
        }
        : isSet(object.chatCompletionComplete)
        ? {
          $case: "chatCompletionComplete",
          chatCompletionComplete: ChatCompletionComplete.fromJSON(object.chatCompletionComplete),
        }
        : isSet(object.revealPreimage)
        ? { $case: "revealPreimage", revealPreimage: RevealPreimage.fromJSON(object.revealPreimage) }
        : isSet(object.relayError)
        ? { $case: "relayError", relayError: RelayError.fromJSON(object.relayError) }
        : undefined,
    };
  },

  toJSON(message: MessageEnvelope): unknown {
    const obj: any = {};
    if (message.payload?.$case === "registerClientRequest") {
      obj.registerClientRequest = RegisterClientRequest.toJSON(message.payload.registerClientRequest);
    } else if (message.payload?.$case === "registerClientResponse") {
      obj.registerClientResponse = RegisterClientResponse.toJSON(message.payload.registerClientResponse);
    } else if (message.payload?.$case === "registerProviderRequest") {
      obj.registerProviderRequest = RegisterProviderRequest.toJSON(message.payload.registerProviderRequest);
    } else if (message.payload?.$case === "registerProviderResponse") {
      obj.registerProviderResponse = RegisterProviderResponse.toJSON(message.payload.registerProviderResponse);
    } else if (message.payload?.$case === "statusRequest") {
      obj.statusRequest = StatusRequest.toJSON(message.payload.statusRequest);
    } else if (message.payload?.$case === "statusResponse") {
      obj.statusResponse = StatusResponse.toJSON(message.payload.statusResponse);
    } else if (message.payload?.$case === "connectionRequest") {
      obj.connectionRequest = ConnectionRequest.toJSON(message.payload.connectionRequest);
    } else if (message.payload?.$case === "connectionResponse") {
      obj.connectionResponse = ConnectionResponse.toJSON(message.payload.connectionResponse);
    } else if (message.payload?.$case === "registerModelRequest") {
      obj.registerModelRequest = RegisterModelRequest.toJSON(message.payload.registerModelRequest);
    } else if (message.payload?.$case === "registerModelResponse") {
      obj.registerModelResponse = RegisterModelResponse.toJSON(message.payload.registerModelResponse);
    } else if (message.payload?.$case === "chatCompletionRequest") {
      obj.chatCompletionRequest = ChatCompletionRequest.toJSON(message.payload.chatCompletionRequest);
    } else if (message.payload?.$case === "chatCompletionPartial") {
      obj.chatCompletionPartial = ChatCompletionPartial.toJSON(message.payload.chatCompletionPartial);
    } else if (message.payload?.$case === "chatCompletionComplete") {
      obj.chatCompletionComplete = ChatCompletionComplete.toJSON(message.payload.chatCompletionComplete);
    } else if (message.payload?.$case === "revealPreimage") {
      obj.revealPreimage = RevealPreimage.toJSON(message.payload.revealPreimage);
    } else if (message.payload?.$case === "relayError") {
      obj.relayError = RelayError.toJSON(message.payload.relayError);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MessageEnvelope>, I>>(base?: I): MessageEnvelope {
    return MessageEnvelope.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MessageEnvelope>, I>>(object: I): MessageEnvelope {
    const message = createBaseMessageEnvelope();
    switch (object.payload?.$case) {
      case "registerClientRequest": {
        if (object.payload?.registerClientRequest !== undefined && object.payload?.registerClientRequest !== null) {
          message.payload = {
            $case: "registerClientRequest",
            registerClientRequest: RegisterClientRequest.fromPartial(object.payload.registerClientRequest),
          };
        }
        break;
      }
      case "registerClientResponse": {
        if (object.payload?.registerClientResponse !== undefined && object.payload?.registerClientResponse !== null) {
          message.payload = {
            $case: "registerClientResponse",
            registerClientResponse: RegisterClientResponse.fromPartial(object.payload.registerClientResponse),
          };
        }
        break;
      }
      case "registerProviderRequest": {
        if (object.payload?.registerProviderRequest !== undefined && object.payload?.registerProviderRequest !== null) {
          message.payload = {
            $case: "registerProviderRequest",
            registerProviderRequest: RegisterProviderRequest.fromPartial(object.payload.registerProviderRequest),
          };
        }
        break;
      }
      case "registerProviderResponse": {
        if (
          object.payload?.registerProviderResponse !== undefined && object.payload?.registerProviderResponse !== null
        ) {
          message.payload = {
            $case: "registerProviderResponse",
            registerProviderResponse: RegisterProviderResponse.fromPartial(object.payload.registerProviderResponse),
          };
        }
        break;
      }
      case "statusRequest": {
        if (object.payload?.statusRequest !== undefined && object.payload?.statusRequest !== null) {
          message.payload = {
            $case: "statusRequest",
            statusRequest: StatusRequest.fromPartial(object.payload.statusRequest),
          };
        }
        break;
      }
      case "statusResponse": {
        if (object.payload?.statusResponse !== undefined && object.payload?.statusResponse !== null) {
          message.payload = {
            $case: "statusResponse",
            statusResponse: StatusResponse.fromPartial(object.payload.statusResponse),
          };
        }
        break;
      }
      case "connectionRequest": {
        if (object.payload?.connectionRequest !== undefined && object.payload?.connectionRequest !== null) {
          message.payload = {
            $case: "connectionRequest",
            connectionRequest: ConnectionRequest.fromPartial(object.payload.connectionRequest),
          };
        }
        break;
      }
      case "connectionResponse": {
        if (object.payload?.connectionResponse !== undefined && object.payload?.connectionResponse !== null) {
          message.payload = {
            $case: "connectionResponse",
            connectionResponse: ConnectionResponse.fromPartial(object.payload.connectionResponse),
          };
        }
        break;
      }
      case "registerModelRequest": {
        if (object.payload?.registerModelRequest !== undefined && object.payload?.registerModelRequest !== null) {
          message.payload = {
            $case: "registerModelRequest",
            registerModelRequest: RegisterModelRequest.fromPartial(object.payload.registerModelRequest),
          };
        }
        break;
      }
      case "registerModelResponse": {
        if (object.payload?.registerModelResponse !== undefined && object.payload?.registerModelResponse !== null) {
          message.payload = {
            $case: "registerModelResponse",
            registerModelResponse: RegisterModelResponse.fromPartial(object.payload.registerModelResponse),
          };
        }
        break;
      }
      case "chatCompletionRequest": {
        if (object.payload?.chatCompletionRequest !== undefined && object.payload?.chatCompletionRequest !== null) {
          message.payload = {
            $case: "chatCompletionRequest",
            chatCompletionRequest: ChatCompletionRequest.fromPartial(object.payload.chatCompletionRequest),
          };
        }
        break;
      }
      case "chatCompletionPartial": {
        if (object.payload?.chatCompletionPartial !== undefined && object.payload?.chatCompletionPartial !== null) {
          message.payload = {
            $case: "chatCompletionPartial",
            chatCompletionPartial: ChatCompletionPartial.fromPartial(object.payload.chatCompletionPartial),
          };
        }
        break;
      }
      case "chatCompletionComplete": {
        if (object.payload?.chatCompletionComplete !== undefined && object.payload?.chatCompletionComplete !== null) {
          message.payload = {
            $case: "chatCompletionComplete",
            chatCompletionComplete: ChatCompletionComplete.fromPartial(object.payload.chatCompletionComplete),
          };
        }
        break;
      }
      case "revealPreimage": {
        if (object.payload?.revealPreimage !== undefined && object.payload?.revealPreimage !== null) {
          message.payload = {
            $case: "revealPreimage",
            revealPreimage: RevealPreimage.fromPartial(object.payload.revealPreimage),
          };
        }
        break;
      }
      case "relayError": {
        if (object.payload?.relayError !== undefined && object.payload?.relayError !== null) {
          message.payload = { $case: "relayError", relayError: RelayError.fromPartial(object.payload.relayError) };
        }
        break;
      }
    }
    return message;
  },
};

function bytesFromBase64(b64: string): Uint8Array {
  if ((globalThis as any).Buffer) {
    return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
  } else {
    const bin = globalThis.atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
      arr[i] = bin.charCodeAt(i);
    }
    return arr;
  }
}

function base64FromBytes(arr: Uint8Array): string {
  if ((globalThis as any).Buffer) {
    return globalThis.Buffer.from(arr).toString("base64");
  } else {
    const bin: string[] = [];
    arr.forEach((byte) => {
      bin.push(globalThis.String.fromCharCode(byte));
    });
    return globalThis.btoa(bin.join(""));
  }
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends { $case: string } ? { [K in keyof Omit<T, "$case">]?: DeepPartial<T[K]> } & { $case: T["$case"] }
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function longToNumber(int64: { toString(): string }): number {
  const num = globalThis.Number(int64.toString());
  if (num > globalThis.Number.MAX_SAFE_INTEGER) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (num < globalThis.Number.MIN_SAFE_INTEGER) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return num;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
